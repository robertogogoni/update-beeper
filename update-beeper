#!/bin/bash
# ~/bin/update-beeper - Smart Beeper updater with self-healing
# Features: auto-retry, self-healing, health checks, automatic rollback

set -e

BEEPER_API="https://api.beeper.com/desktop/download/linux/x64/stable/com.automattic.beeper.desktop"
CHANGELOG_URL="https://www.beeper.com/changelog/desktop"
INSTALL_DIR="/opt/beeper"
BACKUP_DIR="/opt/beeper-backups"
TMP_DIR="/tmp/beeper-update"
BEEPER_CONFIG="$HOME/.config/BeeperTexts"
USER_DESKTOP_DIR="$HOME/.local/share/applications"

# Wayland flags for native rendering (fixes blank windows on Hyprland/Sway)
WAYLAND_FLAGS="--enable-features=UseOzonePlatform --ozone-platform=wayland"

# Minimum expected AppImage size (Beeper is ~200MB)
MIN_APPIMAGE_SIZE=150000000  # 150MB

# Minimum required free space (500MB for download + extraction + buffer)
MIN_FREE_SPACE_MB=500

# Retry limits
MAX_DOWNLOAD_RETRIES=2
MAX_EXTRACTION_RETRIES=2
MAX_STARTUP_RETRIES=2

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Flags
CHECK_ONLY=false
NOTIFY=false
FORCE=false
SHOW_CHANGELOG=false
SCRIPT_EXIT_CODE=0

# Track which backup to use for rollback
ROLLBACK_BACKUP=""

usage() {
    echo "Usage: update-beeper [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  --check, -c       Check for updates without installing"
    echo "  --changelog, -l   Show changelog for installed version"
    echo "  --notify, -n      Send desktop notification (for cron/timer use)"
    echo "  --force, -f       Force update even if already on latest"
    echo "  --help, -h        Show this help message"
    echo ""
    echo "Beeper will automatically restart after updating."
    echo "If update fails, automatic rollback will restore the previous version."
    echo ""
    echo "Wayland Support:"
    echo "  On Wayland (Hyprland, Sway, etc.), this script automatically:"
    echo "  - Tests Beeper with native Wayland flags (fixes blank windows)"
    echo "  - Creates ~/.local/share/applications/beeper.desktop override"
    exit 0
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --check|-c) CHECK_ONLY=true; shift ;;
        --changelog|-l) SHOW_CHANGELOG=true; shift ;;
        --notify|-n) NOTIFY=true; shift ;;
        --force|-f) FORCE=true; shift ;;
        --help|-h) usage ;;
        *) echo "Unknown option: $1"; usage ;;
    esac
done

cleanup() {
    rm -rf "$TMP_DIR" 2>/dev/null || true
}
trap cleanup EXIT

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# SYSTEM COMPATIBILITY CHECKS
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

check_architecture() {
    local arch
    arch=$(uname -m)
    if [[ "$arch" != "x86_64" ]]; then
        echo -e "${RED}âŒ Unsupported architecture: $arch${NC}"
        echo -e "   Beeper Desktop only provides x86_64 (64-bit) builds."
        echo -e "   Your system architecture: $arch"
        exit 1
    fi
}

check_distro() {
    # Check if this is an Arch-based distro
    if ! command -v pacman &>/dev/null; then
        echo -e "${YELLOW}âš  Warning: This script is designed for Arch Linux${NC}"
        echo -e "   pacman not found - you may be on a different distro."
        echo -e "   The script will still work, but AUR features won't be available."
        echo ""
    fi
}

check_dependencies() {
    local missing=()

    # Required dependencies
    for cmd in curl sudo; do
        if ! command -v "$cmd" &>/dev/null; then
            missing+=("$cmd")
        fi
    done

    if [[ ${#missing[@]} -gt 0 ]]; then
        echo -e "${RED}âŒ Missing required dependencies: ${missing[*]}${NC}"
        echo -e "   Install them with: sudo pacman -S ${missing[*]}"
        exit 1
    fi

    # Optional dependencies (just warn)
    if ! command -v notify-send &>/dev/null; then
        if [[ "$NOTIFY" == true ]]; then
            echo -e "${YELLOW}âš  notify-send not found - notifications disabled${NC}"
            echo -e "   Install with: sudo pacman -S libnotify"
            NOTIFY=false
        fi
    fi
}

check_system_compatibility() {
    check_architecture
    check_distro
    check_dependencies
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# UTILITY FUNCTIONS
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Version comparison: returns 0 if $1 >= $2
version_gte() {
    printf '%s\n%s\n' "$2" "$1" | sort -V -C
}

send_notification() {
    if command -v notify-send &>/dev/null; then
        notify-send -i beepertexts "Beeper Update" "$1"
    fi
}

show_changelog() {
    # Get installed version
    local version=""
    if [[ -f "$INSTALL_DIR/resources/app/package.json" ]]; then
        version=$(grep -oP '"version":\s*"\K[0-9]+\.[0-9]+\.[0-9]+' "$INSTALL_DIR/resources/app/package.json" | head -1)
    fi

    if [[ -z "$version" ]]; then
        echo -e "${RED}âœ— Could not determine installed Beeper version${NC}"
        return 1
    fi

    echo -e "${BLUE}ğŸ“‹ Beeper Changelog${NC}"
    echo -e "   Installed version: ${GREEN}$version${NC}"
    echo ""
    echo -e "   Opening changelog in browser..."

    # Open changelog in default browser
    if command -v xdg-open &>/dev/null; then
        xdg-open "$CHANGELOG_URL" 2>/dev/null &
    elif command -v open &>/dev/null; then
        open "$CHANGELOG_URL" 2>/dev/null &
    else
        echo -e "${YELLOW}   Could not open browser automatically.${NC}"
        echo -e "   Visit: ${CHANGELOG_URL}"
    fi

    echo ""
    echo -e "   ${YELLOW}Tip: Search for '$version' on the page to find your version's changes.${NC}"
    return 0
}

check_versions() {
    # Get installed version
    INSTALLED=$(pacman -Q beeper-v4-bin 2>/dev/null | awk '{print $2}' | cut -d'-' -f1)

    # Fallback: check package.json if pacman doesn't know
    if [[ -z "$INSTALLED" ]] && [[ -f "$INSTALL_DIR/resources/app/package.json" ]]; then
        INSTALLED=$(grep -oP '"version":\s*"\K[0-9]+\.[0-9]+\.[0-9]+' "$INSTALL_DIR/resources/app/package.json" | head -1)
    fi

    # Get latest version from API
    DOWNLOAD_URL=$(curl -Ls -o /dev/null -w "%{url_effective}" "$BEEPER_API")
    LATEST=$(echo "$DOWNLOAD_URL" | grep -oP 'Beeper-\K[0-9]+\.[0-9]+\.[0-9]+')

    # Get AUR version
    AUR=$(curl -sL "https://aur.archlinux.org/packages/beeper-v4-bin" 2>/dev/null | \
          grep -oP '4\.\d+\.\d+' | head -1)
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# VERIFICATION FUNCTIONS
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

verify_sudo_access() {
    echo "   Checking sudo access..."
    if ! sudo -v 2>/dev/null; then
        echo -e "${RED}   âœ— sudo access required but not available${NC}"
        echo -e "${YELLOW}   Please run with sudo privileges or ensure sudo is configured${NC}"
        return 1
    fi
    echo -e "${GREEN}   âœ“ sudo access OK${NC}"
    return 0
}

verify_system_requirements() {
    local errors=0

    echo "   Checking system requirements..."

    # Check network connectivity
    if ! curl -s --connect-timeout 5 --head https://api.beeper.com >/dev/null 2>&1; then
        echo -e "${RED}   âœ— Cannot reach Beeper servers (network issue?)${NC}"
        errors=$((errors + 1))
    else
        echo -e "${GREEN}   âœ“ Network connectivity OK${NC}"
    fi

    # Check /opt is writable (with sudo)
    if ! sudo test -w /opt 2>/dev/null; then
        echo -e "${RED}   âœ— /opt is not writable${NC}"
        errors=$((errors + 1))
    else
        echo -e "${GREEN}   âœ“ /opt writable${NC}"
    fi

    # Check /tmp is writable
    if ! test -w /tmp; then
        echo -e "${RED}   âœ— /tmp is not writable${NC}"
        errors=$((errors + 1))
    else
        echo -e "${GREEN}   âœ“ /tmp writable${NC}"
    fi

    # Check required commands exist
    local required_cmds=("curl" "stat" "grep" "sed" "tar")
    for cmd in "${required_cmds[@]}"; do
        if ! command -v "$cmd" &>/dev/null; then
            echo -e "${RED}   âœ— Required command not found: $cmd${NC}"
            errors=$((errors + 1))
        fi
    done

    # Check if another update is in progress
    if [[ -d "$TMP_DIR" ]] && pgrep -f "update-beeper" | grep -v $$ >/dev/null 2>&1; then
        echo -e "${RED}   âœ— Another update-beeper process may be running${NC}"
        errors=$((errors + 1))
    fi

    # Check if Beeper is running (warn only)
    if pgrep -x "beepertexts" >/dev/null; then
        echo -e "${YELLOW}   âš  Beeper is running (will be restarted after update)${NC}"
    fi

    if [[ $errors -gt 0 ]]; then
        echo -e "${RED}   âœ— Found $errors system issues${NC}"
        return 1
    fi

    echo -e "${GREEN}   âœ“ All system requirements met${NC}"
    return 0
}

verify_permissions() {
    local install_dir="$1"
    local errors=0

    echo "   Verifying permissions..."

    # Check directory exists
    if [[ ! -d "$install_dir" ]]; then
        echo -e "${RED}   âœ— Install directory not found: $install_dir${NC}"
        return 1
    fi

    # Check ownership (should be root:root)
    local owner
    owner=$(stat -c '%U:%G' "$install_dir" 2>/dev/null)
    if [[ "$owner" != "root:root" ]]; then
        echo -e "${RED}   âœ— Wrong ownership: $owner (expected root:root)${NC}"
        errors=$((errors + 1))
    fi

    # Check directory permissions (should be 755)
    local dir_perms
    dir_perms=$(stat -c '%a' "$install_dir" 2>/dev/null)
    if [[ "$dir_perms" != "755" ]]; then
        echo -e "${RED}   âœ— Wrong directory permissions: $dir_perms (expected 755)${NC}"
        errors=$((errors + 1))
    fi

    # Check chrome-sandbox has setuid (should be 4755)
    if [[ -f "$install_dir/chrome-sandbox" ]]; then
        local sandbox_perms
        sandbox_perms=$(stat -c '%a' "$install_dir/chrome-sandbox" 2>/dev/null)
        if [[ "$sandbox_perms" != "4755" ]]; then
            echo -e "${RED}   âœ— chrome-sandbox missing setuid: $sandbox_perms (expected 4755)${NC}"
            errors=$((errors + 1))
        fi
    fi

    # Check main binary is executable
    if [[ -f "$install_dir/beepertexts" ]]; then
        if [[ ! -x "$install_dir/beepertexts" ]]; then
            echo -e "${RED}   âœ— beepertexts not executable${NC}"
            errors=$((errors + 1))
        fi
    fi

    if [[ $errors -gt 0 ]]; then
        echo -e "${RED}   âœ— Found $errors permission issues${NC}"
        return 1
    fi

    echo -e "${GREEN}   âœ“ All permissions correct${NC}"
    return 0
}

verify_disk_space() {
    local target_dir="$1"
    local required_mb="$2"

    # Get available space in MB
    local available_mb
    available_mb=$(df -m "$target_dir" 2>/dev/null | awk 'NR==2 {print $4}')

    if [[ -z "$available_mb" ]]; then
        echo -e "${YELLOW}   âš  Could not check disk space${NC}"
        return 0  # Continue anyway
    fi

    if [[ $available_mb -lt $required_mb ]]; then
        echo -e "${RED}   âœ— Insufficient disk space: ${available_mb}MB available, need ${required_mb}MB${NC}"
        return 1
    fi
    echo -e "${GREEN}   âœ“ Disk space OK: ${available_mb}MB available${NC}"
    return 0
}

verify_download() {
    local file="$1"
    local size
    size=$(stat -c%s "$file" 2>/dev/null || echo 0)

    if [[ $size -lt $MIN_APPIMAGE_SIZE ]]; then
        echo -e "${RED}   âœ— Download too small: ${size} bytes (expected >150MB)${NC}"
        return 1
    fi
    echo -e "${GREEN}   âœ“ Download size OK: $((size / 1024 / 1024))MB${NC}"
    return 0
}

verify_extraction() {
    local extract_dir="$1"
    local critical_files=("beepertexts" "snapshot_blob.bin" "v8_context_snapshot.bin" "resources/app/package.json")

    if [[ ! -d "$extract_dir" ]]; then
        echo -e "${RED}   âœ— Extraction failed! squashfs-root not found.${NC}"
        return 1
    fi

    echo "   Verifying extraction..."
    for f in "${critical_files[@]}"; do
        if [[ ! -f "$extract_dir/$f" ]]; then
            echo -e "${RED}   âœ— Extraction incomplete! Missing: $f${NC}"
            return 1
        fi
    done
    echo -e "${GREEN}   âœ“ All critical files present${NC}"
    return 0
}

verify_installed_version() {
    local expected_version="$1"
    local package_json="$INSTALL_DIR/resources/app/package.json"

    # Debug: show what we're looking for
    echo "   Looking for: $package_json"
    ls -la "$INSTALL_DIR/resources/app/" 2>&1 | head -3 | sed 's/^/   /'

    if [[ ! -f "$package_json" ]]; then
        echo -e "${RED}   âœ— package.json not found after install${NC}"
        echo "   Debug: Contents of $INSTALL_DIR:"
        ls -la "$INSTALL_DIR/" 2>&1 | head -5 | sed 's/^/   /'
        return 1
    fi

    local actual_version
    actual_version=$(grep -oP '"version":\s*"\K[0-9]+\.[0-9]+\.[0-9]+' "$package_json" | head -1)

    if [[ "$actual_version" == "$expected_version" ]]; then
        echo -e "${GREEN}   âœ“ Version verified: $actual_version${NC}"
        return 0
    else
        echo -e "${RED}   âœ— Version mismatch! Expected: $expected_version, Got: $actual_version${NC}"
        return 1
    fi
}

verify_beeper_starts() {
    echo "   Verifying Beeper starts correctly..."

    # Check display availability
    if [[ -z "$DISPLAY" ]] && [[ -z "$WAYLAND_DISPLAY" ]]; then
        echo -e "${YELLOW}   âš  No display detected, skipping startup verification${NC}"
        return 0
    fi

    # Kill any existing instance
    pkill beepertexts 2>/dev/null || true
    sleep 2

    # Determine launch command - use Wayland flags if on Wayland
    local launch_cmd="beeper"
    if [[ -n "$WAYLAND_DISPLAY" ]]; then
        launch_cmd="$INSTALL_DIR/beepertexts $WAYLAND_FLAGS"
        echo -e "${BLUE}   Using Wayland-native rendering${NC}"
    fi

    # Start fresh and capture PID
    nohup $launch_cmd >/tmp/beeper-verify.log 2>&1 &
    local beeper_pid=$!

    # Check at intervals (catch early crashes + give time to stabilize)
    local prev_wait=0
    for wait_time in 3 6 10; do
        sleep $((wait_time - prev_wait))
        prev_wait=$wait_time

        if ! kill -0 $beeper_pid 2>/dev/null; then
            echo -e "${RED}   âœ— Beeper crashed within ${wait_time}s${NC}"
            echo "   Last log output:"
            cat /tmp/beeper-verify.log 2>/dev/null | tail -10 | sed 's/^/   /'
            return 1
        fi
    done

    # Final check
    if pgrep -x "beepertexts" >/dev/null; then
        echo -e "${GREEN}   âœ“ Beeper running stable after 10s${NC}"
        return 0
    else
        echo -e "${RED}   âœ— Beeper process disappeared${NC}"
        return 1
    fi
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# FIX & RECOVERY FUNCTIONS
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

clear_electron_cache() {
    echo "   Clearing Electron cache..."
    rm -rf "$BEEPER_CONFIG/Cache" 2>/dev/null || true
    rm -rf "$BEEPER_CONFIG/GPUCache" 2>/dev/null || true
    rm -rf "$BEEPER_CONFIG/Code Cache" 2>/dev/null || true
    rm -rf "$BEEPER_CONFIG/DawnCache" 2>/dev/null || true
}

fix_and_retry() {
    local failure_type="$1"
    local attempt="$2"

    echo -e "${YELLOW}   ğŸ”§ Attempting fix for: $failure_type (attempt $attempt)${NC}"

    case "$failure_type" in
        download)
            echo "   â†’ Clearing temp and freeing space..."
            rm -rf "$TMP_DIR"
            # Clean old beeper update attempts that might be taking space
            rm -rf /tmp/beeper-update 2>/dev/null || true
            mkdir -p "$TMP_DIR"

            # Re-check disk space after cleanup
            local available
            available=$(df -m /tmp 2>/dev/null | awk 'NR==2 {print $4}')
            echo "   â†’ Available space after cleanup: ${available:-unknown}MB"
            sleep 2
            ;;
        extraction)
            echo "   â†’ Cleaning extraction artifacts and freeing space..."
            rm -rf "$TMP_DIR/squashfs-root"
            # Clean any partial extractions from previous runs
            rm -rf /tmp/beeper-update/squashfs-root 2>/dev/null || true

            # Check if disk space is the issue
            local available
            available=$(df -m /tmp 2>/dev/null | awk 'NR==2 {print $4}')
            if [[ -n "$available" ]] && [[ $available -lt 300 ]]; then
                echo -e "${RED}   âš  Low disk space (${available}MB) - this may be causing extraction failures${NC}"
                # Try to free more space
                echo "   â†’ Attempting to free more space..."
                rm -rf /tmp/beeper-*.log 2>/dev/null || true
                rm -rf "$BEEPER_CONFIG/Cache" 2>/dev/null || true
                available=$(df -m /tmp 2>/dev/null | awk 'NR==2 {print $4}')
                echo "   â†’ Available after cleanup: ${available:-unknown}MB"
            fi
            sleep 1
            ;;
        version)
            echo "   â†’ Version mismatch - clearing everything for fresh download..."
            rm -rf "$TMP_DIR"
            rm -rf /tmp/beeper-update 2>/dev/null || true
            mkdir -p "$TMP_DIR"
            ;;
        startup)
            echo "   â†’ Clearing Electron caches that may cause startup issues..."
            clear_electron_cache
            # Also try fixing permissions in case they got corrupted
            echo "   â†’ Re-applying correct permissions..."
            sudo chown -R root:root "$INSTALL_DIR" 2>/dev/null || true
            sudo chmod 755 "$INSTALL_DIR" 2>/dev/null || true
            sudo chmod 4755 "$INSTALL_DIR/chrome-sandbox" 2>/dev/null || true
            sleep 2
            ;;
        permissions)
            echo "   â†’ Fixing file permissions (recursive)..."
            sudo chown -R root:root "$INSTALL_DIR"
            # Fix ALL directories to 755
            sudo find "$INSTALL_DIR" -type d -exec chmod 755 {} \; 2>/dev/null || true
            # Fix chrome-sandbox setuid
            sudo chmod 4755 "$INSTALL_DIR/chrome-sandbox" 2>/dev/null || true
            # Fix executables
            sudo chmod 755 "$INSTALL_DIR/beepertexts" 2>/dev/null || true
            sudo chmod 755 "$INSTALL_DIR/AppRun" 2>/dev/null || true
            sudo chmod 755 "$INSTALL_DIR"/*.so 2>/dev/null || true
            sudo chmod 755 "$INSTALL_DIR/chrome_crashpad_handler" 2>/dev/null || true
            ;;
    esac
}

backup_current() {
    if [[ -d "$INSTALL_DIR" ]]; then
        sudo mkdir -p "$BACKUP_DIR"
        ROLLBACK_BACKUP="beeper-backup-$(date +%Y%m%d-%H%M%S)"
        echo "   Creating backup: $ROLLBACK_BACKUP"
        sudo cp -a "$INSTALL_DIR" "$BACKUP_DIR/$ROLLBACK_BACKUP"

        # Keep only last 3 backups (subshell to avoid directory leak)
        (cd "$BACKUP_DIR" && ls -t | tail -n +4 | xargs -r sudo rm -rf)
    fi
}

rollback_to_backup() {
    echo -e "${YELLOW}ğŸ”„ Rolling back to previous version...${NC}"

    # Find the backup to restore
    local backup_to_restore=""

    if [[ -n "$ROLLBACK_BACKUP" ]] && [[ -d "$BACKUP_DIR/$ROLLBACK_BACKUP" ]]; then
        backup_to_restore="$BACKUP_DIR/$ROLLBACK_BACKUP"
    else
        # Find most recent backup
        backup_to_restore=$(ls -td "$BACKUP_DIR"/*/ 2>/dev/null | head -1)
    fi

    if [[ -z "$backup_to_restore" ]] || [[ ! -d "$backup_to_restore" ]]; then
        echo -e "${RED}âŒ No backup available for rollback!${NC}"
        return 1
    fi

    echo "   Restoring from: $(basename "$backup_to_restore")"
    sudo rm -rf "$INSTALL_DIR"
    sudo cp -a "$backup_to_restore" "$INSTALL_DIR"

    # Verify rollback worked
    if verify_beeper_starts; then
        echo -e "${GREEN}âœ… Rollback successful!${NC}"

        # Update desktop file to reflect rolled-back version
        local rollback_version
        rollback_version=$(grep -oP '"version":\s*"\K[0-9]+\.[0-9]+\.[0-9]+' "$INSTALL_DIR/resources/app/package.json" | head -1)
        sudo sed -i "s/X-AppImage-Version=.*/X-AppImage-Version=$rollback_version/" \
            /usr/share/applications/beeper.desktop

        return 0
    else
        echo -e "${RED}âŒ Rollback failed! Manual intervention required.${NC}"
        return 1
    fi
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# INSTALLATION FUNCTIONS
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

apply_patches() {
    local extract_dir="$1"

    echo "   Applying patches..."
    # Fix AppRun script (same as AUR)
    sed -Ei 's@^(if \[ -z "\$APPDIR" \] ; then)$@APPDIR="/opt/beeper"\n\1@' \
        "$extract_dir/AppRun"

    # Disable auto-update prompts (same as AUR)
    sed -i 's/export{[a-zA-Z0-9_]* as registerLinuxConfig};/const noopFunc=function(){};export{noopFunc as registerLinuxConfig};/' \
        "$extract_dir/resources/app/build/main/linux-"*.mjs 2>/dev/null || true

    echo -e "${GREEN}   âœ“ Patches applied${NC}"
}

install_files() {
    local extract_dir="$1"

    echo "   Installing (requires sudo)..."
    if ! sudo rm -rf "$INSTALL_DIR"; then
        echo -e "${RED}   âœ— Failed to remove old installation${NC}"
        return 1
    fi

    if ! sudo mv "$extract_dir" "$INSTALL_DIR"; then
        echo -e "${RED}   âœ— Failed to move new installation${NC}"
        return 1
    fi

    # Fix ownership and permissions (critical for Electron sandbox)
    echo "   Setting ownership and permissions..."
    if ! sudo chown -R root:root "$INSTALL_DIR"; then
        echo -e "${RED}   âœ— Failed to set ownership${NC}"
        return 1
    fi

    # Fix ALL directory permissions recursively (755 for dirs, 644/755 for files)
    echo "   Setting directory permissions (recursive)..."
    if ! sudo find "$INSTALL_DIR" -type d -exec chmod 755 {} \; 2>/dev/null; then
        echo -e "${RED}   âœ— Failed to set directory permissions${NC}"
        return 1
    fi

    # Make sure executables are executable
    sudo chmod 755 "$INSTALL_DIR/beepertexts" 2>/dev/null || true
    sudo chmod 755 "$INSTALL_DIR/AppRun" 2>/dev/null || true
    sudo chmod 755 "$INSTALL_DIR"/*.so 2>/dev/null || true
    sudo chmod 755 "$INSTALL_DIR/chrome_crashpad_handler" 2>/dev/null || true

    # Set chrome-sandbox setuid (critical for Electron sandbox)
    if ! sudo chmod 4755 "$INSTALL_DIR/chrome-sandbox"; then
        echo -e "${RED}   âœ— Failed to set chrome-sandbox setuid${NC}"
        return 1
    fi

    # Verify permissions were applied correctly
    if ! verify_permissions "$INSTALL_DIR"; then
        echo -e "${YELLOW}   âš  Permissions verification failed, attempting fix...${NC}"
        fix_and_retry "permissions" 1

        # Re-verify after fix
        if ! verify_permissions "$INSTALL_DIR"; then
            echo -e "${RED}   âœ— Could not fix permissions${NC}"
            return 1
        fi
    fi

    # Update desktop file version
    sudo sed -i "s/X-AppImage-Version=.*/X-AppImage-Version=$LATEST/" \
        /usr/share/applications/beeper.desktop

    echo -e "${GREEN}   âœ“ Files installed with correct permissions${NC}"
    return 0
}

setup_wayland_desktop_override() {
    # Only set up Wayland override if running on Wayland
    if [[ -z "$WAYLAND_DISPLAY" ]]; then
        return 0
    fi

    echo "   Setting up Wayland desktop override..."
    mkdir -p "$USER_DESKTOP_DIR"

    local system_desktop="/usr/share/applications/beeper.desktop"
    local user_desktop="$USER_DESKTOP_DIR/beeper.desktop"

    if [[ ! -f "$system_desktop" ]]; then
        echo -e "${YELLOW}   âš  System desktop file not found, skipping Wayland override${NC}"
        return 0
    fi

    # Copy system desktop file and add Wayland flags
    cp "$system_desktop" "$user_desktop"

    # Update the Exec line to include Wayland flags
    # Match various possible Exec patterns and insert Wayland flags
    sed -i "s|^Exec=beeper |Exec=beeper $WAYLAND_FLAGS |" "$user_desktop"
    sed -i "s|^Exec=/opt/beeper/beepertexts |Exec=/opt/beeper/beepertexts $WAYLAND_FLAGS |" "$user_desktop"

    # Update desktop database
    update-desktop-database "$USER_DESKTOP_DIR" 2>/dev/null || true

    echo -e "${GREEN}   âœ“ Wayland desktop override configured${NC}"
    echo -e "${BLUE}   â†’ Beeper will use native Wayland rendering when launched from app menu${NC}"
    return 0
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# MAIN UPDATE LOGIC WITH SELF-HEALING
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

do_direct_install() {
    local download_attempt=0
    local appimage="Beeper-${LATEST}-x86_64.AppImage"
    local extract_dir="$TMP_DIR/squashfs-root"

    mkdir -p "$TMP_DIR"

    #â”€â”€ Step 0: Check disk space â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    echo -e "${BLUE}ğŸ’¾ Checking disk space...${NC}"
    if ! verify_disk_space "/tmp" "$MIN_FREE_SPACE_MB"; then
        echo -e "${RED}âŒ Not enough space in /tmp for download and extraction${NC}"
        echo -e "${YELLOW}   Try: sudo rm -rf /tmp/beeper-update${NC}"
        return 1
    fi

    # Download & Extract loop with retries
    while [[ $download_attempt -lt $MAX_DOWNLOAD_RETRIES ]]; do
        download_attempt=$((download_attempt + 1))

        #â”€â”€ Step 1: Download â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        echo -e "${BLUE}ğŸ“¥ Downloading... (attempt $download_attempt/$MAX_DOWNLOAD_RETRIES)${NC}"

        if ! curl -L --progress-bar -o "$TMP_DIR/$appimage" "$DOWNLOAD_URL"; then
            echo -e "${RED}   âœ— Download failed${NC}"
            fix_and_retry "download" $download_attempt
            continue
        fi
        chmod +x "$TMP_DIR/$appimage"

        #â”€â”€ Step 2: Verify download â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if ! verify_download "$TMP_DIR/$appimage"; then
            fix_and_retry "download" $download_attempt
            continue
        fi

        #â”€â”€ Step 3: Extract with retries â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        local extraction_attempt=0
        local extraction_success=false

        while [[ $extraction_attempt -lt $MAX_EXTRACTION_RETRIES ]]; do
            extraction_attempt=$((extraction_attempt + 1))

            echo -e "${BLUE}ğŸ“¦ Extracting... (attempt $extraction_attempt/$MAX_EXTRACTION_RETRIES)${NC}"
            rm -rf "$extract_dir"

            # Capture extraction output/errors (run in TMP_DIR via subshell)
            local extract_log="/tmp/beeper-extract-$$.log"
            if (cd "$TMP_DIR" && ./"$appimage" --appimage-extract) >"$extract_log" 2>&1; then
                if verify_extraction "$extract_dir"; then
                    rm -f "$extract_log"
                    extraction_success=true
                    break
                else
                    echo -e "${RED}   âœ— Extraction completed but files missing${NC}"
                fi
            else
                echo -e "${RED}   âœ— Extraction command failed${NC}"
                echo "   Last extraction output:"
                tail -5 "$extract_log" 2>/dev/null | sed 's/^/   /'
            fi
            rm -f "$extract_log"

            fix_and_retry "extraction" $extraction_attempt
        done

        if [[ "$extraction_success" == true ]]; then
            break  # Success! Exit download loop
        fi

        # Extraction failed all attempts - try fresh download
        echo -e "${YELLOW}   Extraction failed, trying fresh download...${NC}"
        fix_and_retry "download" $download_attempt
    done

    # Check if we succeeded
    if ! verify_extraction "$extract_dir" 2>/dev/null; then
        echo -e "${RED}âŒ Download/extraction failed after all retries${NC}"
        return 1
    fi

    #â”€â”€ Step 4: Apply patches â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    apply_patches "$extract_dir"

    #â”€â”€ Step 5: Backup current installation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    echo -e "${BLUE}ğŸ’¾ Backing up current version...${NC}"
    backup_current

    #â”€â”€ Step 6: Install files â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    echo -e "${BLUE}ğŸ“ Installing new version...${NC}"
    install_files "$extract_dir"

    #â”€â”€ Step 7: Verify installed version â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    echo -e "${BLUE}ğŸ” Verifying installation...${NC}"
    if ! verify_installed_version "$LATEST"; then
        echo -e "${RED}   Version verification failed${NC}"
        return 1
    fi

    #â”€â”€ Step 7.5: Set up Wayland desktop override (if on Wayland) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if [[ -n "$WAYLAND_DISPLAY" ]]; then
        echo -e "${BLUE}ğŸ–¥ï¸  Configuring Wayland support...${NC}"
    fi
    setup_wayland_desktop_override

    #â”€â”€ Step 8: Verify Beeper starts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    local startup_attempt=0

    while [[ $startup_attempt -lt $MAX_STARTUP_RETRIES ]]; do
        startup_attempt=$((startup_attempt + 1))

        echo -e "${BLUE}ğŸš€ Testing startup... (attempt $startup_attempt/$MAX_STARTUP_RETRIES)${NC}"

        if verify_beeper_starts; then
            return 0  # SUCCESS!
        fi

        if [[ $startup_attempt -lt $MAX_STARTUP_RETRIES ]]; then
            fix_and_retry "startup" $startup_attempt
        fi
    done

    # Startup failed after all retries
    echo -e "${RED}   Startup verification failed after all retries${NC}"
    return 1
}

perform_update() {
    echo -e "${YELLOW}âš¡ AUR is behind ($AUR). Installing directly...${NC}"
    echo ""

    if do_direct_install; then
        echo ""
        echo -e "${GREEN}âœ… Successfully updated to $LATEST!${NC}"
        echo -e "${YELLOW}âš ï¸  Note: Run 'yay -Syu beeper-v4-bin' when AUR catches up to resync.${NC}"

        if [[ "$NOTIFY" == true ]]; then
            send_notification "Updated to $LATEST"
        fi
        return 0
    else
        echo ""
        echo -e "${RED}âŒ Update failed!${NC}"

        if rollback_to_backup; then
            echo -e "${GREEN}Previous version restored.${NC}"
            if [[ "$NOTIFY" == true ]]; then
                send_notification "Update to $LATEST failed - rolled back"
            fi
        else
            if [[ "$NOTIFY" == true ]]; then
                send_notification "Update to $LATEST failed - rollback also failed!"
            fi
        fi
        return 1
    fi
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# MAIN ENTRY POINT
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Verify system compatibility first
check_system_compatibility

# Handle changelog display (early exit)
if [[ "$SHOW_CHANGELOG" == true ]]; then
    show_changelog
    exit $?
fi

echo -e "${BLUE}ğŸ” Checking versions...${NC}"
check_versions

echo "   Installed: ${INSTALLED:-unknown}"
echo "   Latest:    ${LATEST:-unknown}"
echo "   AUR:       ${AUR:-unknown}"

# Validate we got version info
if [[ -z "$LATEST" ]]; then
    echo -e "${RED}âŒ Could not determine latest version from Beeper API${NC}"
    exit 1
fi

# Compare versions
if [[ "$FORCE" != true ]] && version_gte "$INSTALLED" "$LATEST"; then
    echo -e "${GREEN}âœ… You're on the latest version!${NC}"
    exit 0
fi

# Update available
echo ""
echo -e "${YELLOW}ğŸ”„ Update available: ${INSTALLED:-unknown} â†’ $LATEST${NC}"

# Check-only mode
if [[ "$CHECK_ONLY" == true ]]; then
    if [[ "$NOTIFY" == true ]]; then
        send_notification "Update available: ${INSTALLED:-unknown} â†’ $LATEST"
    fi
    exit 0
fi

# Verify sudo access before any installation
echo -e "${BLUE}ğŸ” Checking prerequisites...${NC}"
if ! verify_sudo_access; then
    echo -e "${RED}âŒ Cannot proceed without sudo access${NC}"
    exit 1
fi

# System-wide requirements check
if ! verify_system_requirements; then
    echo -e "${RED}âŒ System requirements not met${NC}"
    exit 1
fi

# Pre-flight system check: verify and fix current installation permissions
echo -e "${BLUE}ğŸ”§ Pre-flight system check...${NC}"
if [[ -d "$INSTALL_DIR" ]]; then
    if ! verify_permissions "$INSTALL_DIR"; then
        echo -e "${YELLOW}   âš  Current installation has permission issues, fixing...${NC}"
        fix_and_retry "permissions" 1

        if verify_permissions "$INSTALL_DIR"; then
            echo -e "${GREEN}   âœ“ Permissions fixed${NC}"
        else
            echo -e "${RED}   âœ— Could not fix current installation permissions${NC}"
            echo -e "${YELLOW}   Proceeding anyway - new installation will have correct permissions${NC}"
        fi
    fi
else
    echo -e "${YELLOW}   âš  No existing installation found at $INSTALL_DIR${NC}"
fi

# Try AUR first if it has the latest
if version_gte "$AUR" "$LATEST"; then
    echo -e "${BLUE}ğŸ“¦ Updating via yay...${NC}"
    if yay -Syu --noconfirm beeper-v4-bin; then
        echo -e "${GREEN}âœ… Updated to $LATEST via AUR!${NC}"

        # Set up Wayland desktop override
        setup_wayland_desktop_override

        # Verify startup - if it fails, try fixes before declaring success
        if verify_beeper_starts; then
            exit 0
        else
            echo -e "${YELLOW}âš ï¸  Startup verification failed, trying fixes...${NC}"
            clear_electron_cache
            sleep 2
            if verify_beeper_starts; then
                echo -e "${GREEN}âœ… Fixed with cache clear${NC}"
                exit 0
            else
                echo -e "${RED}âŒ AUR update completed but Beeper won't start${NC}"
                echo -e "${YELLOW}   Try: update-beeper --force${NC}"
                exit 1
            fi
        fi
    else
        echo -e "${YELLOW}âš ï¸  AUR update failed, falling back to direct install...${NC}"
    fi
fi

# Direct install with self-healing
if perform_update; then
    exit 0
else
    exit 1
fi
